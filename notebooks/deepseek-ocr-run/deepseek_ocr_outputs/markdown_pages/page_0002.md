- Avoid using images in your text; use a link instead.


Recurrent models typically factor computation along the symbol positions of the input and output sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden states \( h_t \), as function of the previous hidden state \( h_{t-1} \) and the input position \( t \). This inherently sequential nature precludes parallelism within training examples, which becomes critical at longer sequences. To address this limitation, researchers have proposed various approaches such as recurrently significant improvements in computational efficiency through factorization tricks [13] and conditional computation [28], while also improving model performance in case of the latter. The fundamental constraint of sequential computations, however, remains: 


Attention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their duration in the input or output sequences [210]. In that it has a few cases [23], however, we admit attention machines are used in conjunction with a recurrent network. 


In this work we propose the Transformer, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output. The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs. 


## 2 Background 


The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [25]. ByteNet [25] and ConvS3X [8], all of which use convolutional neural networks as basic building block, computing hidden representations related for all input and output positions. In these models, the number of operations required to realize signals from two arbitrary input or output positions grows in the distance between positions. Invariably ConvS3X and logarithmically for ByteNet. This makes it more difficult to learn dependencies between the outputs [10]. In the Transformer this is achieved by introducing self-attention operations, albeit at the cost of reduced effective resolution due to averaging attentional weights' positions, an effect we constructed with Multi-Head Attention as described in section2.4. 


Self-attentions, sometimes called intra-attentions in an attentive mechanism relating different positions of a single sequence in order to compute a representation of the sequence. Self-attentions has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning task-independent sentence representations [612][213][219]. 


End-to-end memory networks are based on a recurrent attention mechanism instead of sequence-aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [22]. 


To be the end of knowledge, however, the Transformer is the first transformation model relying entirely on self-attentional compute representations in input and output without using sequence aligned RNNs or activations. In the following sections, we will show the Transformer, motivate self-attention and discuss its advantages over models such as [133] [5] and [6]. 


### 3 Model Architecture 


Most competitive neural sequence transduction models have an encoder-decoder structure [619][29]. Here, the encoder maps an input sequence of symbol representations \((x_1,\ldots,x_n)\) to a sequence of continuous representations \(\mathbf{z} = \{z_1,\ldots,z_m\}\). Given \(\mathbf{x}\) , the decoder then generates an output sequence \((\hat{y}_1,\ldots,\hat{y}_m)\) of symbols one element at a time. At each step the model is auto-regressive [20], consuming the previously generated symbols as additional input when generating the next. 


The Transformer follows this overall architecture using stacked self-attention and point-wise fully connected layers for both the encoder and decoder, shown in the left and right halves of Figure[7] respectively. 


### 3.1 Encoder and Decoder Stacks 


**Encoder:** The encoder is composed of a stack of \(N=6\) identical layers. Each layer has two sub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, position
